package simpledb;
import java.util.*;
import java.io.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

    private JoinPredicate _predicate;
    private DbIterator _outerRelation;
    private DbIterator _innerRelation;
    private DbIterator _innerIterator;
    private Iterator<Tuple> _outerPage=null;
    private Iterator<Tuple> _innerPage=null;

    private Tuple _outerRecent=null;
    private Tuple _innerRecent=null;

    private int _joinType = 0;
    private int _numMatches =0;
    private int _numComp=0;
    private int _innerScore;
    private int _done=0;

  
    public static final int SNL = 0;
    public static final int PNL = 1;    
    public static final int BNL = 2;    
    public static final int SMJ = 3;    
    public static final int HJ = 4;    
    /**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
	//IMPLEMENT THIS
    	_predicate = p;
        _outerRelation = child1;
        _innerRelation = child2;
        
    }

    public void setJoinAlgorithm(int joinAlgo){
	_joinType = joinAlgo;
    }
    
    /**
     * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible implementation logic.
     */
    public TupleDesc getTupleDesc() {
	//IMPLEMENT THIS
	return null;
    }

    public void open()
        throws DbException, NoSuchElementException, TransactionAbortedException, IOException {
		//IMPLEMENT THIS
    	_outerRelation.open();
    	_innerRelation.open();
    	
    }

    public void close() {
//IMPLEMENT THIS
    	_outerRelation.close();
    	_innerRelation.close();
    }

    public void rewind() throws DbException, TransactionAbortedException, IOException {
//IMPLEMENT THIS
 //   	_outerRelation.rewind();
 //   	_innerRelation.rewind();
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @throws TransactionAbortedException 
     * @throws DbException 
     * @see JoinPredicate#filter
     */
 //   protected Tuple readNext() throws TransactionAbortedException, DbException {
    protected Tuple readNext() throws DbException, TransactionAbortedException{
    switch(_joinType){
	case SNL: return SNL_readNext();
	case PNL: return PNL_readNext();
	case BNL: return BNL_readNext();
	case SMJ: return SMJ_readNext();
	case HJ: return HJ_readNext();
	default: return PNL_readNext();
	}
    }

    protected Tuple SNL_readNext() throws TransactionAbortedException, DbException {
	//IMPLEMENT THIS 
 
    	TupleDesc td;
    	int flag=0;
    	td = TupleDesc.combine( _outerRelation.getTupleDesc(), _innerRelation.getTupleDesc() );
		Tuple retTuple=new Tuple(td);
		_numComp++;
		try {
			
			if(_outerRecent==null)
				_outerRecent=_outerRelation.next();
			do
			{
			if(!_innerRelation.hasNext())
			{
				if(!_outerRelation.hasNext())
					return null;	
				_innerRelation.rewind();
				_outerRecent=_outerRelation.next();
			}
			_innerRecent = _innerRelation.next();
			if(_predicate.filter(_outerRecent, _innerRecent))
				retTuple = joinTuple(_outerRecent,_innerRecent,td);
			}while(!_predicate.filter(_outerRecent, _innerRecent));

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return retTuple;
    }


    protected Tuple PNL_readNext() throws TransactionAbortedException, DbException {
	//IMPLEMENT THIS (EXTRA CREDIT ONLY)
    	TupleDesc td;
    	int flag=0;
    	td = TupleDesc.combine( _outerRelation.getTupleDesc(), _innerRelation.getTupleDesc() );
		Tuple retTuple=new Tuple(td);
		_numComp++;
//		System.out.println("This test");
		
		try
		{
		do
		{
			HeapFileIterator outerIterator = ((HeapFileIterator)((SeqScan)_outerRelation).getIterator());
			HeapPage outerPage = (HeapPage) outerIterator.getCurrentPage();
			_outerPage = outerPage.iterator();
			do
			{
				_outerRecent=_outerPage.next();
				_outerRelation.next();
				do
				{
					_innerRecent=_innerPage.next();
					_innerRelation.next();
					if(_predicate.filter(_outerRecent, _innerRecent))
					{
						retTuple = joinTuple(_outerRecent,_innerRecent,td);
						return retTuple;
					}
				}while(_innerRelation.hasNext());
			}while(_outerPage.hasNext() & _outerRelation.hasNext());
		}while(_outerRelation.hasNext());	
		}catch (IOException e) {
			e.printStackTrace();
		}
		return retTuple;
    }


    protected Tuple BNL_readNext() throws TransactionAbortedException, DbException {
	//no need to implement this
	return null;
    }


    protected Tuple SMJ_readNext() throws TransactionAbortedException, DbException {
	//IMPLEMENT THIS. YOU CAN ASSUME THE JOIN PREDICATE IS ALWAYS =
    	TupleDesc td;
    	td = TupleDesc.combine(_outerRelation.getTupleDesc(), _innerRelation.getTupleDesc());
		Tuple retTuple=new Tuple(td);


		try {
			
		if(_done ==1)
		{
//			System.out.println("Terminating");
			return null;
		}
			
		
		if(_outerRecent ==null)
			_outerRecent = _outerRelation.next();

		if(_innerRecent==null)
			_innerRecent = _innerRelation.next();
		int outerValue=((IntField)_predicate.getLeftField(_outerRecent)).getValue();
		int innerValue=((IntField)_predicate.getRightField(_innerRecent)).getValue();
		
		while(!_predicate.filter(_outerRecent,_innerRecent))
		{
			outerValue = ((IntField)_predicate.getLeftField(_outerRecent)).getValue();
			innerValue = ((IntField)_predicate.getRightField(_innerRecent)).getValue();

			if(outerValue < innerValue)
			{	
				if(!_outerRelation.hasNext())
					return null;

				_outerRecent = _outerRelation.next();
				outerValue = ((IntField)_predicate.getLeftField(_outerRecent)).getValue();				
				if(outerValue == _innerScore)
				{
					_innerRelation.rewind();
					_innerRecent=_innerRelation.next();
					innerValue = ((IntField)_predicate.getRightField(_innerRecent)).getValue();
				}
			}
			if(outerValue > innerValue)
			{

				if(!_innerRelation.hasNext())
					return null;
				_innerRecent = _innerRelation.next();
			}
		}
		_innerScore = innerValue;
		retTuple= joinTuple(_outerRecent,_innerRecent, td);
		if(!_innerRelation.hasNext())
		{
			if (!_outerRelation.hasNext())
			_done=1;
			else
			{
				_outerRecent=_outerRelation.next();
				_innerRelation.rewind();
				_innerRecent = _innerRelation.next();
			}
		}
		else
			_innerRecent=_innerRelation.next();
		return retTuple;
		
		}catch (IOException e) {
			e.printStackTrace();
		}
		
		return null;
    }

    protected Tuple HJ_readNext() throws TransactionAbortedException, DbException {
	//no need to implement this
	return null;
    }


    private Tuple joinTuple(Tuple outer, Tuple inner, TupleDesc tupledesc){
	//IMPLEMENT THIS
		Tuple retTuple = new Tuple(tupledesc);
 //   	if(_predicate.filter(outer,inner))
 //   	{
			//System.out.println("Reached Here");
    		_numMatches++;
    		for (int i=0; i<outer.getTupleDesc().numFields(); i++){
			    retTuple.setField(i, outer.getField(i));
			}
			for (int j=0; j<inner.getTupleDesc().numFields(); j++){
			    retTuple.setField(inner.getTupleDesc().numFields()+j, inner.getField(j));
			}
			return retTuple;
  //  	}
//		return null;
    }

    public int getNumMatches(){
	return _numMatches;
    }
    public int getNumComp(){
	return _numComp;
    }
}
